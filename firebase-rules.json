{
  "rules": {
    // System config - read for all, write only for encryptionSalt
    "system": {
      ".read": true,
      "encryptionSalt": {
        ".write": "!data.exists()"
      },
      "latestVersion": {
        ".write": false
      },
      "releaseNotes": {
        ".write": false
      },
      "motd": {
        ".write": false
      }
    },

    // Pissbot AI config - temporarily writable for setup
    "pissbot": {
      ".read": true,
      ".write": true
    },

    // User presence - users can only write their own presence
    "users": {
      ".read": true,
      "$peerId": {
        ".write": true,
        ".validate": "newData.hasChildren(['peerId', 'displayName', 'lastSeen']) && newData.child('peerId').val() == $peerId && newData.child('displayName').val().length <= 32"
      }
    },

    // Messages - anyone can read/write, with index for cleanup queries
    "messages": {
      ".read": true,
      "$channelId": {
        ".indexOn": ["timestamp"],
        "$messageId": {
          ".write": true,
          ".validate": "newData.hasChildren(['sender', 'content', 'timestamp']) && newData.child('content').val().length <= 4000 && newData.child('sender').val().length <= 32"
        }
      }
    },

    // Join requests - anyone can read/write their own requests
    "joinRequests": {
      ".read": true,
      "$channelId": {
        "$peerId": {
          ".write": true,
          ".validate": "newData.hasChildren(['peerId', 'displayName', 'timestamp']) && newData.child('peerId').val() == $peerId"
        }
      }
    },

    // Audio transcripts cache - stores Gemini transcriptions to avoid re-processing
    "transcripts": {
      ".read": true,
      "$transcriptId": {
        ".write": true,
        ".validate": "newData.hasChildren(['transcript', 'audioUrl', 'createdAt']) && newData.child('transcript').val().length <= 10000"
      }
    }
  }
}
